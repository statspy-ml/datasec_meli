"""
SQLAlchemy models for database tables
Compatible with both SQLite and PostgreSQL
"""

from datetime import datetime
from typing import Optional, Dict, Any
from sqlalchemy import Column, String, Text, DateTime, Integer, JSON
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid

from src.services.database import Base

class AgentInteraction(Base):
    """Model for agent-to-agent interactions"""
    __tablename__ = "agent_interactions"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    session_id = Column(String(36), nullable=False, index=True)
    from_agent = Column(String(50), nullable=False)
    to_agent = Column(String(50), nullable=True)
    message_type = Column(String(100), nullable=False)
    content = Column(JSON, nullable=False)  # Use JSON for PostgreSQL, Text for SQLite
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<AgentInteraction(id={self.id}, from_agent={self.from_agent}, to_agent={self.to_agent})>"

class AgentDecision(Base):
    """Model for agent decisions and rationale"""
    __tablename__ = "agent_decisions"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    agent = Column(String(50), nullable=False)
    session_id = Column(String(36), nullable=False, index=True)
    decision = Column(String(200), nullable=False)
    rationale = Column(Text, nullable=False)
    data = Column(JSON, nullable=True)  # Additional decision data
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<AgentDecision(id={self.id}, agent={self.agent}, decision={self.decision})>"

class SessionModel(Base):
    """Model for analysis sessions"""
    __tablename__ = "sessions"
    
    session_id = Column(String(36), primary_key=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    status = Column(String(20), default='active', nullable=False)
    session_metadata = Column(JSON, nullable=True)  # Session metadata
    ecosystem_description = Column(Text, nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    
    def __repr__(self):
        return f"<SessionModel(session_id={self.session_id}, status={self.status})>"

class SecurityDetector(Base):
    """Model for security detectors generated by the system"""
    __tablename__ = "security_detectors"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    session_id = Column(String(36), nullable=False, index=True)
    name = Column(String(200), nullable=False)
    description = Column(Text, nullable=False)
    priority = Column(String(20), nullable=False)  # high, medium, low
    risk_score = Column(String(10), nullable=False)  # Store as string to handle decimals
    impact_level = Column(String(20), nullable=False)  # critical, high, medium, low
    implementation_effort = Column(String(20), nullable=False)  # high, medium, low
    rationale = Column(Text, nullable=False)
    mitre_techniques = Column(JSON, nullable=True)  # List of MITRE techniques
    attack_vectors = Column(JSON, nullable=True)  # Related attack vectors
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<SecurityDetector(id={self.id}, name={self.name}, priority={self.priority})>"

class ThreatIntelligence(Base):
    """Model for storing extracted threat intelligence from DBIR and other sources"""
    __tablename__ = "threat_intelligence"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    source = Column(String(100), nullable=False)  # DBIR, MITRE, etc.
    threat_name = Column(String(200), nullable=False)
    threat_type = Column(String(100), nullable=False)  # attack_pattern, malware, etc.
    frequency = Column(String(10), nullable=True)  # Frequency percentage
    severity = Column(String(20), nullable=False)
    description = Column(Text, nullable=False)
    attack_vectors = Column(JSON, nullable=True)
    affected_industries = Column(JSON, nullable=True)
    detection_methods = Column(JSON, nullable=True)
    mitre_techniques = Column(JSON, nullable=True)
    raw_data = Column(JSON, nullable=True)  # Original extracted data
    extracted_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    def __repr__(self):
        return f"<ThreatIntelligence(id={self.id}, source={self.source}, threat_name={self.threat_name})>"

class AnalysisResult(Base):
    """Model for storing complete analysis results"""
    __tablename__ = "analysis_results"
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    session_id = Column(String(36), nullable=False, index=True, unique=True)
    ecosystem_context = Column(JSON, nullable=False)  # Parsed ecosystem information
    identified_threats = Column(JSON, nullable=False)  # Threats from DBIR
    security_detectors = Column(JSON, nullable=False)  # Generated detectors
    risk_assessment = Column(JSON, nullable=True)  # Risk scores and analysis
    recommendations = Column(JSON, nullable=True)  # Final recommendations
    analysis_metadata = Column(JSON, nullable=True)  # Analysis process metadata
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), nullable=True)
    
    def __repr__(self):
        return f"<AnalysisResult(id={self.id}, session_id={self.session_id})>"

# Table definitions for direct table access (fallback for non-ORM usage)
agent_interactions_table = AgentInteraction.__table__
agent_decisions_table = AgentDecision.__table__
sessions_table = SessionModel.__table__
security_detectors_table = SecurityDetector.__table__
threat_intelligence_table = ThreatIntelligence.__table__
analysis_results_table = AnalysisResult.__table__